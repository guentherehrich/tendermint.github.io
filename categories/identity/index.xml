<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Identity on Tendermint</title>
    <link>http://tendermint.com/categories/identity/</link>
    <description>Recent content in Identity on Tendermint</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 25 Jan 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://tendermint.com/categories/identity/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Identity on the blockchain</title>
      <link>http://tendermint.com/posts/identity-on-the-blocckhain/</link>
      <pubDate>Mon, 25 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/posts/identity-on-the-blocckhain/</guid>
      <description>&lt;p&gt;Authentication is about determining the authenticity of identity.
But when we&amp;rsquo;re dealing with digital information, there&amp;rsquo;s no way to identify an individual with 100% certainty.
What we&amp;rsquo;re left with is a collection of heuristics.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There are auth consumers, users, and auth providers.

&lt;ul&gt;
&lt;li&gt;An auth consumer consumes auth information.  A consumer-facing website might be an auth consumer.&lt;/li&gt;
&lt;li&gt;Users delegate one or more auth providers to identify them.  A user&amp;rsquo;s phone can be an auth provider, but it could be a third party service provider.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Users want to protect their identity and privacy.

&lt;ul&gt;
&lt;li&gt;Auth consumers should not communicate directly with auth providers.&lt;/li&gt;
&lt;li&gt;Users need multiple options and failover mechanisms in case a particular auth provider option gets compromised.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A user has a pseudonumous (or identified) account on a blockchain where the user can define any set of parameters for identification.
These parameters are not published on the blockchain, but they are Merkle-ized, and the root hash is stored in the blockchain along with the account.&lt;/p&gt;

&lt;p&gt;e.g. The blockchain contains a list of &lt;code&gt;[AccountID,AuthRootHash]&lt;/code&gt; tuples, where &lt;code&gt;AuthRootHash&lt;/code&gt; is the Merkle root of many options for authentication.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AuthRootHash := MerkleRoot(AuthOption1,AuthOption2,AuthOption3...)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So given a user with pseudonymous account &lt;code&gt;AccountID&lt;/code&gt;, anyone can see that account&amp;rsquo;s &lt;code&gt;AuthRootHash&lt;/code&gt;, but not the associated underlying &lt;code&gt;AuthOptions&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For the sake of illustration, lets assume that &lt;code&gt;AuthOption1&lt;/code&gt; is a simple Ed25519 public key, and that the private key is in your phone.&lt;/p&gt;

&lt;p&gt;Now, say the user wishes to sign up with a service (an auth consumer). The service can challenge the user to authenticate themself by providing a challenge string.
The user can then respond with a signature of that challenge string using the public key (which is &lt;code&gt;AuthOption1&lt;/code&gt;) and a Merkle proof that proves that the public key
is part of &lt;code&gt;AuthRootHash&lt;/code&gt;, and thus a legitimate method of authenticating the user.  It&amp;rsquo;s easy to construct the Merkle hash &lt;code&gt;AuthRootHash&lt;/code&gt; in such a way that
no information about any of the other &lt;code&gt;AuthOptions&lt;/code&gt; leak while authenticating with &lt;code&gt;AuthOption1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In practice, there will need to be more than one way to authenticate oneself.&lt;/p&gt;

&lt;p&gt;An &lt;code&gt;[AUTH_OPTION]&lt;/code&gt; encodes how this user may be identified, and options that define privileges associated with this authentication method.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[AUTH_OPTION]&lt;/code&gt; is composed of three parts: &lt;code&gt;[TYPE][DATA][PRIVILEGES]&lt;/code&gt;.
&lt;code&gt;[TYPE]&lt;/code&gt; is a byte or number that characterizes the following data.  For example, a byte of 0x01 may indicate that the data is a naive threshold signature scheme.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[AUTH_OPTION]:&lt;/code&gt; &lt;code&gt;[0x01][2 of 3][PUBKEY1][PUBKEY2][PUBKEY3]][PRIVILEGES]&lt;/code&gt; encodes a threshold signature scheme where two of three signatures is required to authorize.
&lt;code&gt;[PUBKEY]&lt;/code&gt; may similarly be typed.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>